import { defineStore } from 'pinia'
import { supabase } from '../lib/supabase'

export const usePracticeStore = defineStore('practice', {
  state: () => ({
    todaySentence: null,
    loading: false,
    sessions: [],
    userProgress: null,
    customContent: [],
    currentCustomContent: null
  }),

  actions: {
    async fetchTodaySentence() {
      this.loading = true
      try {
        const today = new Date().toISOString().split('T')[0]

        // Fetch all sentences for today
        const { data: sentences, error: fetchError } = await supabase
          .from('daily_sentences')
          .select('*')
          .eq('date', today)

        if (fetchError) throw fetchError

        if (sentences && sentences.length > 0) {
          // Pick a random sentence from today's sentences
          const randomIndex = Math.floor(Math.random() * sentences.length)
          this.todaySentence = sentences[randomIndex]
          return this.todaySentence
        }

        // If no sentences exist, they will be generated by the backend cron job
        // For now, return an error
        throw new Error('No sentences available for today. Please wait for the daily generation.')
      } catch (error) {
        console.error('Error fetching sentence:', error)
        throw error
      } finally {
        this.loading = false
      }
    },

    async savePracticeSession(sentenceId, accuracyScore, duration, aiScore = null, customContentId = null) {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      const sessionData = {
        user_id: user.id,
        accuracy_score: accuracyScore,
        ai_score: aiScore,
        duration_seconds: duration,
        completed: accuracyScore >= 70 // Consider 70% as completed
      }

      // Add either sentence_id or custom_content_id
      if (customContentId) {
        sessionData.custom_content_id = customContentId
      } else {
        sessionData.sentence_id = sentenceId
      }

      const { data, error } = await supabase
        .from('practice_sessions')
        .insert(sessionData)
        .select()
        .single()

      if (error) throw error

      // Update user progress
      await this.updateUserProgress()

      return data
    },

    async updateUserProgress() {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      // Get all sessions
      const { data: sessions } = await supabase
        .from('practice_sessions')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })

      if (!sessions || sessions.length === 0) return

      const totalSessions = sessions.length
      const completedSessions = sessions.filter(s => s.completed).length
      const avgAccuracy = sessions.reduce((acc, s) => acc + parseFloat(s.accuracy_score), 0) / totalSessions

      // Calculate streak
      const { currentStreak, longestStreak } = this.calculateStreaks(sessions)

      const today = new Date().toISOString().split('T')[0]

      // Upsert progress
      const { error } = await supabase
        .from('user_progress')
        .upsert({
          user_id: user.id,
          total_sessions: totalSessions,
          total_sentences: completedSessions,
          average_accuracy: avgAccuracy.toFixed(2),
          current_streak: currentStreak,
          longest_streak: longestStreak,
          last_practice_date: today,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        })

      if (error) console.error('Error updating progress:', error)
    },

    calculateStreaks(sessions) {
      if (!sessions || sessions.length === 0) return { currentStreak: 0, longestStreak: 0 }

      const dates = [...new Set(sessions.map(s => s.created_at.split('T')[0]))].sort().reverse()
      
      let currentStreak = 0
      let longestStreak = 0
      let tempStreak = 1

      const today = new Date().toISOString().split('T')[0]
      const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0]

      // Check if practiced today or yesterday for current streak
      if (dates[0] === today || dates[0] === yesterday) {
        currentStreak = 1

        for (let i = 1; i < dates.length; i++) {
          const prevDate = new Date(dates[i - 1])
          const currDate = new Date(dates[i])
          const diffDays = Math.floor((prevDate - currDate) / 86400000)

          if (diffDays === 1) {
            currentStreak++
          } else {
            break
          }
        }
      }

      // Calculate longest streak
      for (let i = 1; i < dates.length; i++) {
        const prevDate = new Date(dates[i - 1])
        const currDate = new Date(dates[i])
        const diffDays = Math.floor((prevDate - currDate) / 86400000)

        if (diffDays === 1) {
          tempStreak++
        } else {
          longestStreak = Math.max(longestStreak, tempStreak)
          tempStreak = 1
        }
      }
      longestStreak = Math.max(longestStreak, tempStreak, currentStreak)

      return { currentStreak, longestStreak }
    },

    async fetchUserProgress() {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data, error } = await supabase
        .from('user_progress')
        .select('*')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error fetching progress:', error)
        return
      }

      this.userProgress = data
      return data
    },

    async fetchRecentSessions(limit = 10) {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data, error } = await supabase
        .from('practice_sessions')
        .select(`
          *,
          daily_sentences (sentence, category)
        `)
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .limit(limit)

      if (error) {
        console.error('Error fetching sessions:', error)
        return []
      }

      this.sessions = data
      return data
    },

    async resetUserData() {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      console.log('Resetting user data for user:', user.id)

      // Delete all practice sessions
      const { error: sessionsError } = await supabase
        .from('practice_sessions')
        .delete()
        .eq('user_id', user.id)

      if (sessionsError) {
        console.error('Error deleting sessions:', sessionsError)
        throw sessionsError
      }
      
      console.log('Practice sessions deleted successfully')

      // Reset user progress
      const { error: progressError } = await supabase
        .from('user_progress')
        .upsert({
          user_id: user.id,
          total_sessions: 0,
          total_sentences: 0,
          average_accuracy: 0,
          current_streak: 0,
          longest_streak: 0,
          last_practice_date: null,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        })

      if (progressError) {
        console.error('Error resetting progress:', progressError)
        throw progressError
      }
      
      console.log('User progress reset successfully')

      // Clear local state
      this.sessions = []
      this.userProgress = null
      this.todaySentence = null
      
      console.log('Local state cleared')
    },

    // Custom Content Methods
    async createCustomContent(content, title = null, category = 'custom') {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      const { data, error } = await supabase
        .from('custom_content')
        .insert({
          user_id: user.id,
          content: content.trim(),
          title: title?.trim() || null,
          category,
          updated_at: new Date().toISOString()
        })
        .select()
        .single()

      if (error) throw error

      // Add to local state
      this.customContent.push(data)
      return data
    },

    async fetchCustomContent() {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return []

      const { data, error } = await supabase
        .from('custom_content')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })

      if (error) {
        console.error('Error fetching custom content:', error)
        return []
      }

      this.customContent = data || []
      return data
    },

    async deleteCustomContent(id) {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      const { error } = await supabase
        .from('custom_content')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id)

      if (error) throw error

      // Remove from local state
      this.customContent = this.customContent.filter(c => c.id !== id)
    },

    async updateCustomContent(id, updates) {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      const { data, error } = await supabase
        .from('custom_content')
        .update({
          ...updates,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single()

      if (error) throw error

      // Update local state
      const index = this.customContent.findIndex(c => c.id === id)
      if (index !== -1) {
        this.customContent[index] = data
      }

      return data
    },

    async toggleFavoriteCustomContent(id) {
      const content = this.customContent.find(c => c.id === id)
      if (!content) return

      await this.updateCustomContent(id, { is_favorite: !content.is_favorite })
    },

    setCurrentCustomContent(content) {
      this.currentCustomContent = content
    },

    clearCurrentCustomContent() {
      this.currentCustomContent = null
    }
  }
})
